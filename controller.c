#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Ambient)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int inhibidas[3];
//Variables de test para sensores y debugear
int test1 = 0;
int test2 = 0;
int test3 = 0;
int test4 = 0;
int test5 = 0;
TSemaphore semaforo;

int MAX_LIGHT = 50;									//Umbral de luz maxima
int MIN_LIGHT = 22;									//Umbral de luz minima
//Distintas velocidades
int FASTEST_VEL = 40;
int FASTER_VEL = 30;
int SMOOTH_VEL = 20;
int APROACH_DIS_WALL = 30;					//Distancia hasta la que va mas rapido el robot al acercarse a una pared
int TARGET_DIS = 25;								//Distancia objetivo pared
int NEAR_DIS = 8;										//Distancia muy cercana: escapar
int MAX_TIME_NEAR_WALL = 6000;			//Tiempo maximo estando cerca de un muro: escapar
int REVERSE_TIME = 1000;						//Tiempo de marcha atras
int APROACH_TIME_LIGHT = 4000;			//Tiempo de seguimiento a luz en linea recta
int MAX_TIME_WITHOUT_WALL = 10000;	//Tiempo maximo sin encontrar un muro


void inhibir_nivel_inferior(int nivel){
	semaphoreLock(semaforo);
  if (bDoesTaskOwnSemaphore(semaforo)){
  	inhibidas[nivel-1] = 1;
  	semaphoreUnlock(semaforo);
  }
}

void desinhibir_nivel_inferior(int nivel){
	semaphoreLock(semaforo);
  if (bDoesTaskOwnSemaphore(semaforo)){
  	inhibidas[nivel-1] = 0;
  	semaphoreUnlock(semaforo);
  }
}

int esta_inhibida(int nivel){
    int inhibido;
    semaphoreLock(semaforo);
    if (bDoesTaskOwnSemaphore(semaforo)){
		inhibido = inhibidas[nivel];
        semaphoreUnlock(semaforo);
    }
    return inhibido;
}

task escapar(){
	bool actuar = false;
	int distance;
	int nivelPrioridad = 3
	clearTimer(T1);
	clearTimer(T2);
	while (true){
		distance = getUSDistance(sonarSensor);
		if (distance >= TARGET_DIS){
			clearTimer(T1);
		}
		if(distance <= NEAR_DIS || getTouchValue(touchSensor) || time1[T1] > MAX_TIME_NEAR_WALL){
			actuar = true;
		}

		if(actuar){
			setLEDColor(ledRed);
			inhibir_nivel_inferior(nivelPrioridad);
			setMotorSpeed(leftMotor, -SMOOTH_VEL);
			setMotorSpeed(rightMotor, -SMOOTH_VEL);
			distance = getUSDistance(sonarSensor);
			if (distance <= TARGET_DIS){
				clearTimer(T2);
			}
			if(time1[T2] > REVERSE_TIME){
				actuar = false;
			}
		}else{
			desinhibir_nivel_inferior(nivelPrioridad);
			clearTimer(T1);
			clearTimer(T2);
		}
	}
}

task seguir_luz(){
	bool actuar = false;
  int orientation_angle = 0;
	int current_angle = 0;
	int current_light = 0;
	int state = 0;
	int max_light = 0;
	int nivelPrioridad = 2
	clearTimer(T4);
	while(true){

		if(esta_inhibida(nivelPrioridad)) {
			inhibir_nivel_inferior(nivelPrioridad);
			actuar = false;
			state = 0;
			clearTimer(T4);
		}
		else {
			current_light = getColorAmbient(colorSensor);
			if(current_light > MIN_LIGHT && current_light < MAX_LIGHT) {
				inhibir_nivel_inferior(nivelPrioridad);
				actuar = true;
      }

			if(actuar){
				setLEDColor(ledOrange);
				if (state == 0) {
					max_light = 0;
					state = 1;
					resetGyro(gyroSensor);
					while(abs(getGyroDegrees(gyroSensor)) <= 360) {
						// Cada cierto tiempo verificamos si se ha inhibido
						if(esta_inhibida(nivelPrioridad) && abs(getGyroDegrees(gyroSensor)) % 30 == 0) {
							inhibir_nivel_inferior(nivelPrioridad);
							actuar = false;
							state = 0;
							clearTimer(T4);
							break;
						}
						if(!esta_inhibida(nivelPrioridad)){
							setMotorSpeed(leftMotor, -SMOOTH_VEL);
							setMotorSpeed(rightMotor, SMOOTH_VEL);
						}
						current_light = getColorAmbient(colorSensor);
						current_angle = getGyroDegrees(gyroSensor);
						if(current_light > max_light) {
							max_light = current_light;
							orientation_angle = current_angle;
						}
					}
				} else if (state == 1) {
					// Regresamos al angulo de menor distancia
					state = 2;
					resetGyro(gyroSensor);
					while(abs(getGyroDegrees(gyroSensor) - orientation_angle) > 1) {
						if(esta_inhibida(nivelPrioridad) && abs(getGyroDegrees(gyroSensor)) % 30 == 0) {
							inhibir_nivel_inferior(nivelPrioridad);
							actuar = false;
							state = 0;
							clearTimer(T4);
							break;
						}
						if(!esta_inhibida(nivelPrioridad)){
							setMotorSpeed(leftMotor, (getGyroDegrees(gyroSensor) < orientation_angle) ? SMOOTH_VEL : -SMOOTH_VEL);
							setMotorSpeed(rightMotor, (getGyroDegrees(gyroSensor) < orientation_angle) ? -SMOOTH_VEL : SMOOTH_VEL);
						}
					}
					clearTimer(T4);
				} else if (state == 2){
					if(!esta_inhibida(nivelPrioridad)){
						setMotorSpeed(leftMotor, SMOOTH_VEL);
						setMotorSpeed(rightMotor, SMOOTH_VEL);
					}

					if (time1[T4] > APROACH_TIME_LIGHT) {
						state = 0;
						clearTimer(T4);
					}
				}

				if (current_light > MAX_LIGHT) {
					actuar = false;
				}

			} else {
				desinhibir_nivel_inferior(nivelPrioridad);
			}
		}
	}
}

task seguir_muros(){
	bool actuar = false;
	int distancia;
	int state = 0;
	int nivelPrioridad = 1
	clearTimer(T3);
	resetGyro(gyroSensor);
	while(true){
		if(esta_inhibida(nivelPrioridad)){
			inhibir_nivel_inferior(nivelPrioridad);
			actuar = false;
			state = 0;
			clearTimer(T3);
			}
		else {
			distancia = getUSDistance(sonarSensor);
			if (distancia <= TARGET_DIS){
				actuar = true;
				inhibir_nivel_inferior(nivelPrioridad);
			}

			if (actuar) {
				setLEDColor(ledGreen);
				if (state == 0){

					state = 1;
					resetGyro(gyroSensor);
					while(abs(getGyroDegrees(gyroSensor)) <= 110){
						if(esta_inhibida(nivelPrioridad) && abs(getGyroDegrees(gyroSensor)) % 30 == 0){
							inhibir_nivel_inferior(nivelPrioridad);
							actuar = false;
							state = 0;
							clearTimer(T3);
							break;
						}
						if(!esta_inhibida(nivelPrioridad)){
							setMotorSpeed(leftMotor, SMOOTH_VEL);
							setMotorSpeed(rightMotor, -SMOOTH_VEL);
						}
					}

				} else {
					if(!esta_inhibida(nivelPrioridad)){
						setMotorSpeed(leftMotor, SMOOTH_VEL);
						setMotorSpeed(rightMotor, FASTEST_VEL);
					}
					if (distancia < TARGET_DIS){
						state = 0;
					}
				}
				distancia = getUSDistance(sonarSensor);
				if (distancia <= TARGET_DIS){
					clearTimer(T3);
				}
				if(time1[T3] > MAX_TIME_WITHOUT_WALL){
					actuar = false;
				}

			} else {
				desinhibir_nivel_inferior(nivelPrioridad);
			}
		}
	}
}

task acercarse_a_pared(){
	int state = 0;
	int current_distance;
	int current_angle;
	int min_distance = 10000; // Distancia mínima inicial grande
 	int min_angle = 0;
 	int nivelPrioridad = 0
 	resetGyro(gyroSensor);
	while (true){
		if (esta_inhibida(nivelPrioridad)){
			state = 0;
		}else {
			if(state == 0){
				state = 1;
				resetGyro(gyroSensor);
				while(abs(getGyroDegrees(gyroSensor)) <= 360) {
					if(esta_inhibida(nivelPrioridad) && abs(getGyroDegrees(gyroSensor)) % 30 == 0){
						state = 0;
						break;
					}
					if(!esta_inhibida(nivelPrioridad)){
						setMotorSpeed(leftMotor, -SMOOTH_VEL);
						setMotorSpeed(rightMotor, SMOOTH_VEL);
					}
					current_distance = getUSDistance(sonarSensor);
					current_angle = getGyroDegrees(gyroSensor);
					if (current_distance < min_distance) {
						min_distance = current_distance;
						min_angle = current_angle;  // Guardamos el mejor ángulo
					}

				}

			}else if(state == 1){
				state = 2;
				// Regresamos al ángulo de menor distancia
				resetGyro(gyroSensor);
				while(abs(getGyroDegrees(gyroSensor) - min_angle) > 1) {
					if(esta_inhibida(nivelPrioridad) && abs(getGyroDegrees(gyroSensor)) % 30 == 0){
						state = 0;
						break;
					}
					// Corregir el ángulo si nos pasamos
					if(getGyroDegrees(gyroSensor) < min_angle && !esta_inhibida(nivelPrioridad)){
						setMotorSpeed(leftMotor, SMOOTH_VEL);
						setMotorSpeed(rightMotor, -SMOOTH_VEL);
					} else if(getGyroDegrees(gyroSensor) >= min_angle && !esta_inhibida(nivelPrioridad)){
						setMotorSpeed(leftMotor, -SMOOTH_VEL);
						setMotorSpeed(rightMotor, SMOOTH_VEL);
					}
				}
			}else{
				// Avanzamos suavemente hacia la pared más cercana
				current_distance = getUSDistance(sonarSensor);
				if (current_distance > APROACH_DIS_WALL && !esta_inhibida(nivelPrioridad)){
					setMotorSpeed(leftMotor, FASTER_VEL);
					setMotorSpeed(rightMotor, FASTER_VEL);
				}else if(current_distance <= APROACH_DIS_WALL && !esta_inhibida(nivelPrioridad)){
					setMotorSpeed(leftMotor, SMOOTH_VEL);
					setMotorSpeed(rightMotor, SMOOTH_VEL);
				}
			}
		}
	}
}

task main(){
	semaphoreInitialize(semaforo);
	inhibidas[0] = 0;
	inhibidas[1] = 0;
	inhibidas[2] = 0;
	startTask(escapar);
	startTask(seguir_luz);
	startTask(seguir_muros);
	startTask(acercarse_a_pared);

	while (true){
		test1 = getGyroDegrees(gyroSensor);
		test2 = getUSDistance(sonarSensor);
		test3 = getColorAmbient(colorSensor);
	}
}
